---
layout: post
title: "Spring 复习（二）"
categories:
- java
---

1. [**学习资料**](http://pan.baidu.com/s/1dE73vJb)  密码：l6ls
2. [**书籍下载**](http://pan.baidu.com/s/1qXZ7nuk)  密码：6zj7
3. **使用的资源**
	1. [深入理解java动态代理](http://www.fmeng.me/java/2016/09/15/java-proxy.html)
	1. [官方网站&emsp;http://projects.spring.io/spring-framework](http://projects.spring.io/spring-framework/)
	1. [dbcp](http://commons.apache.org/proper/commons-dbcp/download_dbcp.cgi)
	2. [c3p0](https://sourceforge.net/projects/c3p0/)
	3. [spring-framework &emsp;jar&emsp;download](http://maven.springframework.org/release/org/springframework/spring-core/4.0.0.RELEASE/)
	1. [**myJar**](http://pan.baidu.com/s/1i4Km1ox) &emsp; 密码：d1cf

------

### <a>目录</a> ###

1. <a href="#1">对AOP的理解</a>
2. <a href="#2">基于注解，面向切面编程</a>
	1. <a href="#21">切面和切入点</a>
		1. <a href="#211">根据方法的签名，配置各种切入点的表达式</a>
	2. <a href="#22">通知注解5种</a>
	3. <a href="#23">代码实现</a>
3. <a href="#3">基于xml，面向切面编程</a>

----

### <a name="1">1. 对AOP的理解</a> ###

1. Joinpoint，连接点。<font color="red">相对于被切的程序而言的，是切实存在的，不可由程序指定</font>
   <br/>如类某个方法调用前、调用后、方法抛出异常后等
2. Pointcut，切点。<font color="red">相对于切面程序而言的,可以由切面程序指定</font>
3. Aspect，横切关注点，横切多个程序的切点

### <a name="2">2. 基于注解，面向切面编程</a> ###
1. <a name="21">切面和切入点</a>
	1. 切面类Class前的注解&emsp;`@Order(2)`、`@Aspect`、`@Component`
	2. 声明切入点表达式<br/>
	`@Pointcut("execution(public int com.atguigu.spring.aop.ArithmeticCalculator.*(..))")`<br/>
	`public void declareJointPointExpression(){}`<br/>
	<font color="red">实现**某个接口**`ArithmeticCalculator`的类在执行某个方法的什么时候(`@Before、@After、@AfterRunning、@AfterThrowing、@Around`)执行</font>
	4. <a name="211">根据方法的签名，配置各种切入点的表达式</a>
		1. `execution * (com.atguigu.spring.ArithmeticCalculator.*(..))`<br/><font color="red">第一个 * 代表任意修饰符及任意返回值。 第二个 * 代表任意方法。 .. 匹配任意数量的参数</font>
		2. `execution (public * ArithmeticCalculator.*(..))`
		3. `* *.sub(..))`
		4. `execution (public double ArithmeticCalculator.*(double, ..))`
		6. 合并切入点表达式<br/>
		`@Pointcut("execution(* *.add(int, ..)) || execution(* *.sub(int, ..))")`<br/>
		`private void loggingOperation(){}`
	3. 切入点表达式的使用<br/>
	`@Before("declareJointPointExpression()")`
	`public void beforeMethod(JoinPoint joinPoint){ // to do something }`
2. <a name="22">通知注解5种</a>
	1. `@Before`<br/>
	`@Before("declareJointPointExpression()")`
	`public void beforeMethod(`<font color="red">`JoinPoint joinPoint`</font>`){ // to do something}`<br/>
	
	2. `@After`<br/>
	<font color="red">`@After("declareJointPointExpression()")`</font><br/>
	`public void afterMethod(JoinPoint joinPoint){}`
	<br/><font color="red">不能访问到返回值。有异常抛出，不会执行</font>
	3. `@AfterRunning`<br/>
	`@AfterReturning(`<font color="red">`value=`</font>`"declareJointPointExpression()",`<font color="red">`returning="result"`</font>`)`<br/>
	`public void afterReturning(JoinPoint joinPoint, `<font color="red">`Object result`</font>`){}`
	<br/><font color="red">可以访问到返回值。有异常抛出，也会执行</font>
	4. `@AfterThrowing`<br/>
	`@AfterThrowing(value="declareJointPointExpression()",
		`<font color="red">`throwing="e"`</font>`)`<br/>
	`public void afterThrowing(JoinPoint joinPoint,`<font color="red">`Exception e`</font>`){}`<br/>
	如果只对某种特殊的异常类型感兴趣, 可以将参数声明为其他异常的参数类型. 然后通知就<font color="red">只在抛出这个类型及其子类的异常时才被执行。</font>
	5. `@Around`

			@Around("execution(public int com.atguigu.spring.aop.ArithmeticCalculator.*(..))")
			public Object aroundMethod(ProceedingJoinPoint pjd){
				
				Object result = null;
				String methodName = pjd.getSignature().getName();
				
				try {
					//前置通知
					System.out.println("The method " + methodName + " begins with " + Arrays.asList(pjd.getArgs()));
					//执行目标方法
					result = pjd.proceed();
					//返回通知
					System.out.println("The method " + methodName + " ends with " + result);
				} catch (Throwable e) {
					//异常通知
					System.out.println("The method " + methodName + " occurs exception:" + e);
					throw new RuntimeException(e);
				}
				//后置通知
				System.out.println("The method " + methodName + " ends");
				
				return result;
			}
		1. 能够全面地控制连接点，<font color="red">可以控制是否执行连接点</font>
		2. <font color="red">参数类型必须是`ProceedingJoinPoint`</font>(继承了`JoinPoint`)
		3. 调用`ProceedingJoinPoint`的<font color="red">`proceed()`方法来执行被代理的方法</font>
		4. 需要返回目标方法执行之后的结果<br/><font color="red">
		`Object result = joinPoint.proceed();`<br/>
		`return result;`</font>
3. <font color="red">引入通知</font>
4. <a name="23">代码实现</a>

applicationContext.xml

	<!-- 配置自动扫描的包 -->
	<context:component-scan base-package="com.atguigu.spring.aop"></context:component-scan>
	<!-- 配置自动为匹配 aspectJ 注解的 Java 类生成代理对象 -->
	<aop:aspectj-autoproxy></aop:aspectj-autoproxy>
LoggingAspect.java

	@Order(2)
	@Aspect
	@Component
	public class LoggingAspect {
		
		/**
		 * 定义一个方法, 用于声明切入点表达式. 一般地, 该方法中再不需要添入其他的代码. 
		 * 使用 @Pointcut 来声明切入点表达式. 
		 * 后面的其他通知直接使用方法名来引用当前的切入点表达式. 
		 */
		@Pointcut("execution(public int com.atguigu.spring.aop.ArithmeticCalculator.*(..))")
		public void declareJointPointExpression(){}
		
		/**
		 * 在 com.atguigu.spring.aop.ArithmeticCalculator 接口的每一个实现类的每一个方法开始之前执行一段代码
		 */
		@Before("declareJointPointExpression()")
		public void beforeMethod(JoinPoint joinPoint){
			String methodName = joinPoint.getSignature().getName();
			Object [] args = joinPoint.getArgs();
			
			System.out.println("The method " + methodName + " begins with " + Arrays.asList(args));
		}
		
		/**
		 * 在方法执行之后执行的代码. 无论该方法是否出现异常
		 */
		@After("declareJointPointExpression()")
		public void afterMethod(JoinPoint joinPoint){
			String methodName = joinPoint.getSignature().getName();
			System.out.println("The method " + methodName + " ends");
		}
		
		/**
		 * 在方法法正常结束受执行的代码
		 * 返回通知是可以访问到方法的返回值的!
		 */
		@AfterReturning(value="declareJointPointExpression()",
				returning="result")
		public void afterReturning(JoinPoint joinPoint, Object result){
			String methodName = joinPoint.getSignature().getName();
			System.out.println("The method " + methodName + " ends with " + result);
		}
		
		/**
		 * 在目标方法出现异常时会执行的代码.
		 * 可以访问到异常对象; 且可以指定在出现特定异常时在执行通知代码
		 */
		@AfterThrowing(value="declareJointPointExpression()",
				throwing="e")
		public void afterThrowing(JoinPoint joinPoint, Exception e){
			String methodName = joinPoint.getSignature().getName();
			System.out.println("The method " + methodName + " occurs excetion:" + e);
		}
	}

### <a name="3">3. 基于xml，面向切面编程</a> ###

	<!-- 1. 配置 bean -->
	<bean id="arithmeticCalculator" 
		class="com.atguigu.spring.aop.xml.ArithmeticCalculatorImpl"></bean>

	<!-- 2. 配置切面的 bean. -->
	<bean id="loggingAspect"
		class="com.atguigu.spring.aop.xml.LoggingAspect"></bean>
	<!-- 3. 配置 AOP -->
	<aop:config>
		<!-- 4. 配置切点表达式 -->
		<aop:pointcut expression="execution(* com.atguigu.spring.aop.xml.ArithmeticCalculator.*(int, int))" 
			id="pointcut"/>
		<!-- 5. 配置切面及通知 -->
		<aop:aspect ref="loggingAspect" order="2">
			<aop:before method="beforeMethod" pointcut-ref="pointcut"/>
			<aop:after method="afterMethod" pointcut-ref="pointcut"/>
			<aop:after-throwing method="afterThrowing" pointcut-ref="pointcut" throwing="e"/>
			<aop:after-returning method="afterReturning" pointcut-ref="pointcut" returning="result"/>
			<!--  
			<aop:around method="aroundMethod" pointcut-ref="pointcut"/>
			-->
		</aop:aspect>	
		<aop:aspect ref="vlidationAspect" order="1">
			<aop:before method="validateArgs" pointcut-ref="pointcut"/>
		</aop:aspect>
	</aop:config>

### 4. AOP的事务控制 ###




